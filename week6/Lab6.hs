module Lab6

where
import Data.List
import System.Random
import Week6
       
{- 
  Assignment 1.
  Time spent: 3 hours
    
  Function that does modular exponentiation of x^y in polynomial time, by
  repeatedly squaring modulo N.
-}

exM' :: Integer -> Integer -> Integer -> Integer
exM' _ 0 1 = 0
exM' _ 0 n = 1
exM' x 1 n = rem x n
exM' x y n = let k = exM' x (y `div` 2) n 
              in if even y
                  then k*k   `rem` n
                  else k*k*x `rem` n


-- Alternative method:
-- Source used for detailed explenation: 
--    http://www.tricki.org/article/To_work_out_powers_mod_n_use_repeated_squaring
exMT2 :: Integer -> Integer -> Integer -> Integer
exMT2 x y n = let 
                squares = squareListMod x y n
                factOf2 = toFactOf2 y 
               in product (zipWith helper squares factOf2) `mod` n where 
                helper x y = if y then x else 1
 
-- Create list of squares
squareListMod :: Integer -> Integer -> Integer -> [Integer]
squareListMod x 0 _ = []
squareListMod x y n = squareList' x 0 y n where
 squareList' x k y n = if (2^k) <= y then (x^(2^k) `mod` n) : squareList' x (k+1)  y n
                       else []

-- Helper method for factorization
toFactOf2 :: Integer -> [Bool]
toFactOf2 = decToBin'
 where
decToBin' 0 = []
decToBin' y = let (a,b) = quotRem y 2 in [(b == 1)] ++ decToBin' a


{- 
  Assignment 2.
  Time spent: 1 hour
  
  Check that your implementation is more efficient than expM by running
  relevant tests and documenting the results.
  
  First relevant test: expM needs to much computation time and exits on big numbers,
  whereas exM' (and exM from Week6.hs) have no problems.
  
-}


{-
  Assignment 3.
  Time Spent: 2 hours
  
  In order to test Fermat's Primality Check (as implemented in function primeF),
  the list of prime numbers generated by Eratosthenes' sieve is useless, for Fermat's
  Primality Check correctly classify the primes as primes. Where the check can go
  wrong is on classifying composite numbers; these can slip through the Fermat test.

  --
  First, mark all the numbers from [2..] as True, which means primes
  Second, if one number can be divided, then mark it as false, which means composites
  Then, filter all the numbers which are marked as false and get the numbers
-}

composites :: [Integer]
composites = map fst (filter (not.snd) sieveC)

sieveC :: [(Integer,Bool)] 
sieveC = sieveCom [(x, True) | x <- [2..]]

sieveCom :: [(Integer,Bool)] -> [(Integer,Bool)]
sieveCom ((x,y):ns) = (x, y): sieveCom ns'
          where ns' = if y then 
                        map (\ (x',y') -> if rem x' x == 0 then 
                                            (x', False) 
                                          else (x', y')) 
                                            ns 
                      else 
                        ns


{- 
  Assignment 4.
  Time spent: 1 hour
  
  Use the list of composite numbers to test Fermat's primality check. What is the
  least composite number that you can find that fools the check, for `testF k` with   
  k = 1; 2; 3 ? What happens if you increase k?

  Answer: If you keep running this test, eventually even the first number will slip through, 
  so 4 is the smallest composite number that is able to slip through the test. 
  
  The larger you make K, the smaller the chance that some number will fall through (as more checks are done), 
  hence the returned number is larger.
-}

testF :: Int -> IO Integer
testF k = let
  comps = composites
 in testF' k comps where
  testF' k (c:cs) = do 
                     a <- primeF k c
                     if a then return c
                     else testF' k cs


{- 
  Assignment 5.  
  Time spent: 1 hour
  
  Use the list generated by the `carmichael` function for a further test of 
  Fermat's primality check.
  
  Answer: All carmichael numbers are fermat liars, which means they satisfy fermats theorem for some base, 
  but actually not prime. Carmichaels numbers might be large, the base for primeF (k) might need to be larger. 
  That explains why no number might be found when running (testCarmichael 1) or (testCarmichael 2)
-}

carmichael :: [Integer]
carmichael = [ (6*k+1)*(12*k+1)*(18*k+1) | 
      k <- [2..], 
      isPrime (6*k+1), 
      isPrime (12*k+1), 
      isPrime (18*k+1) ]


testCarmichael :: Int -> IO Integer
testCarmichael k = let
  carm = carmichael
 in testCarmichael' k carm where
  testCarmichael' k (c:cs) = do
                              a <- primeF k c
                              if a then return c
                              else testCarmichael' k cs
{-
  Assignment 6.
  Time spent: 1 hour
  
  Use the list from the previous exercise to test the Miller-Rabin primality check.
  What do you find?

  Answer: The MR test is more strict than the fermat test since it takes longer 
  and the returned composite number is larger. This means that it correctly 
  classifies more composite numbers as composite.
-}

testMR :: Int -> IO Integer
testMR k = let
  carm = carmichael
 in testMR' k carm where
  testMR' k (c:cs) = do
                      a <- primeMR k c
                      if a then return c
                      else testMR' k cs

{-
  Assignment 7.
  Time spent:
  
  You can use the Miller-Rabin primality check to discover some large Mersenne
  primes. 
  
  The recipe: 
    * Take a large prime p
    * Use the Miller-Rabin algorithm to check whether 2^p - 1 is also prime
    * Check on internet the found numbers  are genuine Mersenne primes. 
    
  Report on your findings:
  
  *** Exception: 95513421886551384655206308507......7518292017809047571302187007 is not a prime.
  *** Exception: 13454128316990507273441234211......1764350982066467259298086911 is not a prime.
  *** Exception: 44623289911632568097011006112......7404020907669595372484820991 is not a prime.
  *** Exception: 19322687615086291723476759454......4336733540374348490407411711 is not a prime.
  *** Exception: 58418267242802372854733467471......1683206676499237077451276287 is not a prime.
  *** Exception: 45694248869511749731339270259......1717409453665661424456695807 is not a prime.
  *** Exception: 70464987632426004362292797550......8632700426437616126333550591 is not a prime.
  *** Exception: 41458733762112420444199482867......8298992738570837806549041151 is not a prime.
  *** Exception: 97602323201420798697706107356......9676091442066691089821073407 is not a prime.
  *** Exception: 18635555394378846803544112604......5808269684026257542991577087 is not a prime.
  *** Exception: 67060881961661014500261912652......5163752049785526783110545407 is not a prime.
  *** Exception: 42815749646525926205600082959......5500798142909609824672022527 is not a prime.
  *** Exception: 96963003772423585678984828780......8127578817493325346244657151 is not a prime

  These numbers are just Mersenne number, not Mersenne primes. A basic theorem about Mersenne
  numbers states that if Mp is prime, then the exponent p must also be prime, but the converse is
  not true
-}

{-
    Frist, generate a random integer;
    Then get the prime at that Integer position.
-}
getPrime :: IO Integer
getPrime =  do
   pos <- randomRIO (100, 1000) -- get a relatively large interger
   return (primes !! pos)       -- get a relatively large prime


{-
  Use primeMR to test whether 2^p-1 is a prime
-}
testMP :: IO()
testMP = do 
   p <- getPrime
   k <- randomRIO (10, 50)
   let n = (2^p-1) in
      do 
        res <- primeMR k n
        if res then print (show n ++ " is a prime")
        else error (show n ++ " is not a prime")