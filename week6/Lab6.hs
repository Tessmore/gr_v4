module Lab6

where
import Data.List
import System.Random
import Week6
       
{- 
  Assignment 1.
  Time spent:
    
  Function that does modular exponentiation of x^y in polynomial time, by
  repeatedly squaring modulo N.
-}
                   
-- Alternative method by Lulu
-- Somehow very similar to week6 version, but stops computing at very big numbers?
exM' :: Integer -> Integer -> Integer -> Integer
exM' _ 0 1 = 0
exM' _ 0 n = 1
exM' x 1 n = rem x n
exM' x y n = let k = exM' x (y `div` 2) n 
              in if even y
                  then k*k   `rem` n
                  else k*k*x `rem` n


-- Alternative method by Tim
-- Source used for detailed explenation: 
--    http://www.tricki.org/article/To_work_out_powers_mod_n_use_repeated_squaring
exMT2 :: Integer -> Integer -> Integer -> Integer
exMT2 x y n = let 
                squares = squareListMod x y n
                factOf2 = toFactOf2 y 
               in product (zipWith helper squares factOf2) `mod` n where 
                helper x y = if y then x else 1
 
squareListMod :: Integer -> Integer -> Integer -> [Integer]
squareListMod x 0 _ = []
squareListMod x y n = squareList' x 0 y n where
 squareList' x k y n = if (2^k) <= y then (x^(2^k) `mod` n) : (squareList' x (k+1)  y n)
                       else []

toFactOf2 :: Integer -> [Bool]
toFactOf2 x = decToBin' x
 where
decToBin' 0 = []
decToBin' y = let (a,b) = quotRem y 2 in [(b == 1)] ++ decToBin' a


{- 
  Assignment 2.
  Time spent:
  
  Check that your implementation is more efficient than expM by running
  relevant tests and documenting the results.

  
-}  


{-
  Assignment 3.
  
  In order to test Fermat's Primality Check (as implemented in function primeF),
  the list of prime numbers generated by Eratosthenes' sieve is useless, for Fermat's
  Primality Check correctly classify the primes as primes. Where the check can go
  wrong is on classifying composite numbers; these can slip through the Fermat test.

  Write `composites` function. It should generate an infinite list of composite 
  natural numbers. 
   
   Hint: modify Eratosthenes' sieve, so that instead of throwing away composite numbers, 
   it marks them as false. Next filter out the numbers marked as false.

-}

--composites :: [Integer]
--composites = composites' [4..]

--composites' (n:ns) = n : composites'
--  (filter (\ m -> rem m n /= 0) ns)


{- 
  Assignment 4.
  Time spent:
  
  Use the list of composite numbers to test Fermat's primality check. What is the
  least composite number that you can find that fools the check, for `testF k` with   
  k = 1; 2; 3 ? What happens if you increase k?

-}



{- 
  Assignment 5.  
  Time spent: 
  
  Use the list generated by the `carmichael` function for a further test of 
  Fermat's primality check. Read the entry on Carmichael numbers on 
  Wikipedia to explain what you find.
-}

carmichael :: [Integer]
carmichael = [ (6*k+1)*(12*k+1)*(18*k+1) | 
      k <- [2..], 
      isPrime (6*k+1), 
      isPrime (12*k+1), 
      isPrime (18*k+1) ]


{-
  Assignment 6.
  Time spent:
  
  Use the list from the previous exercise to test the Miller-Rabin primality check.
  What do you find?
  
-}


{-
  Assignment 7.
  Time spent:
  
  You can use the Miller-Rabin primality check to discover some large Mersenne
  primes. 
  
  The recipe: 
    * Take a large prime p
    * Use the Miller-Rabin algorithm to check whether 2^p - 1 is also prime
    * Check on internet the found numbers  are genuine Mersenne primes. 
    
  Report on your findings
  
-}
