module Lab6

where
import Data.List
import System.Random
import Week6
       
{- 
  Assignment 1.
  Time spent: 3 hours
    
  Function that does modular exponentiation of x^y in polynomial time, by
  repeatedly squaring modulo N.
-}

exM' :: Integer -> Integer -> Integer -> Integer
exM' _ 0 1 = 0
exM' _ 0 n = 1
exM' x 1 n = rem x n
exM' x y n = let k = exM' x (y `div` 2) n 
              in if even y
                  then k*k   `rem` n
                  else k*k*x `rem` n


-- Alternative method:
-- Source used for detailed explenation: 
--    http://www.tricki.org/article/To_work_out_powers_mod_n_use_repeated_squaring
exMT2 :: Integer -> Integer -> Integer -> Integer
exMT2 x y n = let 
                squares = squareListMod x y n
                factOf2 = toFactOf2 y 
               in product (zipWith helper squares factOf2) `mod` n where 
                helper x y = if y then x else 1
 
-- Create list of squares
squareListMod :: Integer -> Integer -> Integer -> [Integer]
squareListMod x 0 _ = []
squareListMod x y n = squareList' x 0 y n where
 squareList' x k y n = if (2^k) <= y then (x^(2^k) `mod` n) : (squareList' x (k+1)  y n)
                       else []

-- Helper method for factorization
toFactOf2 :: Integer -> [Bool]
toFactOf2 x = decToBin' x
 where
decToBin' 0 = []
decToBin' y = let (a,b) = quotRem y 2 in [(b == 1)] ++ decToBin' a


{- 
  Assignment 2.
  Time spent: 1 hour
  
  Check that your implementation is more efficient than expM by running
  relevant tests and documenting the results.
-}  


{-
  Assignment 3.
  Time Spent: 2 hours
  
  In order to test Fermat's Primality Check (as implemented in function primeF),
  the list of prime numbers generated by Eratosthenes' sieve is useless, for Fermat's
  Primality Check correctly classify the primes as primes. Where the check can go
  wrong is on classifying composite numbers; these can slip through the Fermat test.

  --
  First, mark all the numbers from [2..] as True, which means primes
  Second, if one number can be divided, then mark it as false, which means composites
  Then, filter all the numbers which are marked as false and get the numbers
-}

composites' :: [Integer]
composites' = map fst (filter (not.snd) sieveC)

sieveC :: [(Integer,Bool)] 
sieveC = sieveCom [(x, True) | x <- [2..]]

sieveCom :: [(Integer,Bool)] -> [(Integer,Bool)]
sieveCom ((x,y):ns) = (x, y): (sieveCom ns') 
          where ns' =
            if y
              then map (\ (x',y') -> 
                if rem x' x == 0
                  then (x', False)
                else (x', y')) ns
            else ns

{- 
  Assignment 4.
  Time spent: 1 hour
  
  Use the list of composite numbers to test Fermat's primality check. What is the
  least composite number that you can find that fools the check, for `testF k` with   
  k = 1; 2; 3 ? What happens if you increase k?

  Answer: If you keep running this test, eventually even the first number will slip through, 
  so 4 is the smallest composite number that is able to slip through the test. 
  
  The larger you make K, the smaller the chance that some number will fall through (as more checks are done), 
  hence the returned number is larger.
-}

testF :: Int -> IO Integer
testF k = let
  comps = composites
 in testF' k comps where
  testF' k (c:cs) = do 
                     a <- primeF k c
                     if a then return c
                     else testF' k cs


{- 
  Assignment 5.  
  Time spent: 1 hour
  
  Use the list generated by the `carmichael` function for a further test of 
  Fermat's primality check.
  
  Answer: All carmichael numbers are fermat liars, which means they satisfy fermats theorem for some base, 
  but actually not prime. Carmichaels numbers might be large, the base for primeF (k) might need to be larger. 
  That explains why no number might be found when running (testCarmichael 1) or (testCarmichael 2)
-}

carmichael :: [Integer]
carmichael = [ (6*k+1)*(12*k+1)*(18*k+1) | 
      k <- [2..], 
      isPrime (6*k+1), 
      isPrime (12*k+1), 
      isPrime (18*k+1) ]


testCarmichael :: Int -> IO Integer
testCarmichael k = let
  carm = carmichael
 in testCarmichael' k carm where
  testCarmichael' k (c:cs) = do
                              a <- primeF k c
                              if a then return c
                              else testCarmichael' k cs
{-
  Assignment 6.
  Time spent: 1 hour
  
  Use the list from the previous exercise to test the Miller-Rabin primality check.
  What do you find?

  Answer: The MR test is more strict than the fermat test since it takes longer 
  and the returned composite number is larger. This means that it correctly 
  classifies more composite numbers as composite.
-}

testMR :: Int -> IO Integer
testMR k = let
  carm = carmichael
 in testMR' k carm where
  testMR' k (c:cs) = do
                      a <- primeMR k c
                      if a then return c
                      else testMR' k cs

{-
  Assignment 7.
  Time spent:
  
  You can use the Miller-Rabin primality check to discover some large Mersenne
  primes. 
  
  The recipe: 
    * Take a large prime p
    * Use the Miller-Rabin algorithm to check whether 2^p - 1 is also prime
    * Check on internet the found numbers  are genuine Mersenne primes. 
    
  Report on your findings
  
-}

{-
    Frist, generate a random integer;
    Then get the prime at that Integer position.
-}
getPrime :: IO Integer
getPrime =  do
   pos <- randomRIO (100, 1000) --get a relatively large interger
   return (primes !! pos) -- get a relatively large prime


{-
    Use primeMR to test whether 2^p-1 is a prime
-}
testMP :: IO()
testMP = do 
   p <- getPrime
   k <- randomRIO (10, 50)
   let n = (2^p-1) in
      do 
        res <- primeMR k n
        if res then print (show n ++ " is a prime")
        else error (show n ++ " is not a prime")
